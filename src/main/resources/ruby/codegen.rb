#!/usr/bin/env ruby

# This is the scala codegen.  It works by reflecting The generated ruby.

$VERBOSE = nil # Ruby thrift bindings always are noisy

require "fileutils"
require "erb"
include FileUtils

# Stub out thrift.  We just need to have the generated ruby compile, not
# actually run in this context.
module ::Thrift
  module Client; end
  module Processor; end 
  module Struct
    def generate_accessors(*args); end
    def method_missing(*args);end
    extend self
  end
  module Struct_Union; end
  module Types # TODO: support everything
    STRUCT = 1
    I32 = 2
    LIST = 3
    MAP = 4
    STRING = 5
    BOOL = 6
  end
  
  class Exception; end
  
  class ApplicationException
    MISSING_RESULT = nil
    def initialize(*args)
    end
  end
end
def require(*args); end

# Utility stolen from activesupport
class String
  def camelize(first_letter_in_uppercase = false)
    if first_letter_in_uppercase
      gsub(/\/(.?)/) { "::#{$1.upcase}" }.gsub(/(?:^|_)(.)/) { $1.upcase }
    else
      self[0].chr.downcase + camelize(self)[1..-1]
    end
  end    
end

# These functions are macros for common patterns in the generated scala.

def type_of(field, thrifty = false)
  base = case field[:type]
  when ::Thrift::Types::I32: "Int"
  when ::Thrift::Types::STRUCT: thrifty ? $tnamespace + "." + field[:class].to_s : field[:class].to_s
  when ::Thrift::Types::STRING: "String"
  when ::Thrift::Types::BOOL: "Boolean"
  when ::Thrift::Types::LIST:
    tmp = "List[#{type_of(field[:element], thrifty)}]"
    thrifty ? "J#{tmp}" : tmp
  else
    throw "unknown field type: #{field[:type]}"
  end
  field[:optional] ? "Option[#{base}]" : base
end  

def unwrapper(f)
  pre = ""
  post = ""
  case f[:type]
  when ::Thrift::Types::LIST: 
    pre += "asJavaList(("
    a, b = unwrapper(f[:element])
    post += ").map(x => #{a}x#{b}))"
  when ::Thrift::Types::STRUCT: 
    post += ".toThrift"
  end
  [pre, post]
end

def unwrap(f)
  pre, post = unwrapper(f)
  @output << pre
  yield
  @output << post
end

def wrapper(f, name = nil)
  name ||= f[:name].camelize
  case f[:type]
  when ::Thrift::Types::LIST: "asScalaBuffer(#{name}).view.map(x=>#{wrapper(f[:element], "x")}).toList"
  when ::Thrift::Types::STRUCT: "new #{f[:class]}(#{name})"
  else
    name
  end
end

MStruct = Struct.new(:name, :args, :retval)

module Codegen
  def run(input, output, tnamespace, namespace)
    output = File.expand_path(File.join(output, *namespace.split(".")))
    mkdir_p output
    $tnamespace = tnamespace

    # Hooray, we generate the scala with ERb
    service_template_string = '
      package <%=namespace %>

      import java.util.{List => JList, Map => JMap}
      import scala.collection.mutable._
      import scala.collection.JavaConversions._
      import com.twitter.util.Future
      import org.slf4j.LoggerFactory

      // Autogenerated

      trait <%=obj%> {
        <% for m in methods do %>
          def <%=m.name.camelize%>(<%=m.args.map{|f| f[:name].camelize + ": " + type_of(f)}.join(", ") %>): Future[<%=type_of(m.retval)%>]
        <% end %>
      }

      class <%=obj%>ThriftAdapter(val <%=obj.to_s.camelize%>: <%=obj%>) extends <%=tnamespace%>.<%=obj%>.ServiceIface { 
        val logger = LoggerFactory.getLogger(getClass)
        <% for m in methods do %>
          def <%=m.name.downcase%>(<%=m.args.map{|f| f[:name].camelize + ": " + type_of(f, true)}.join(", ") %>) = try {
            <%=obj.to_s.camelize%>.<%=m.name.camelize%>(<%=m.args.map{|f| wrapper(f) }.join(", ")%>).map { retval =>
                    <% unwrap(m.retval) do %>retval<%end%>
            }
          } catch {
            case t: Throwable => {
              logger.error("uncaught error", t)
              throw new <%=tnamespace%>.<%=$exception%>(t.getMessage)
            }
          }
        <% end %>
      }
    '
    
    struct_template_string = '
      package <%=namespace %>

      // Autogenerated

      case class <%=obj%>(<%=fields.map{|f| f[:name].camelize + ": " + type_of(f)}.join(", ") %>) {
        def this(thrifty: <%=tnamespace%>.<%=obj%>) = this(
          <% for f in fields do %>
            <%="," unless f == fields.first %>
            <% if f[:optional] %>
              if(thrifty.isSet<%=f[:name].capitalize%>) {
                Some(<%= wrapper(f, "thrifty.#{f[:name]}")%>)
              } else {
                None
              }
            <% else %>
              <%= wrapper(f, "thrifty.#{f[:name]}")%>
            <% end %>
          <% end %>
        )

        <% if fields.any?{|f| f[:optional]} %>
          def this(<%=fields.map{|f| f[:name].camelize + ": " + type_of(f) unless f[:optional] }.compact.join(", ") %>) = this(<%=fields.map{|f| f[:optional] ? "None" : f[:name].camelize }.join(", ") %>)
        <% end %>

        def toThrift() = {
          val out = new <%=tnamespace%>.<%=obj%>()
          <% for f in fields do %>
            <%="#{f[:name].camelize}.foreach { #{f[:name].camelize} => " if f[:optional] %>
              <% if f[:type] == ::Thrift::Types::STRUCT %>
                out.set<%=f[:name].capitalize%>(<%=f[:name].camelize%>.toThrift)
              <% else %>
                out.set<%=f[:name].capitalize%>(<%=f[:name].camelize%>)
              <% end %>
            <%="}" if f[:optional] %>
          <% end %>
          out
        }
      }
    '

    # Load the thrift files
    cd input
    Dir["*types.rb"].each {|f| load f }
    Dir["*.rb"].each {|f| load f }

    # Scan looking for...
    ObjectSpace.each_object(Class) do |obj|
      
      if obj.method_defined?(:struct_fields) 
        # Looking for structs
        if !obj.to_s[/::/]
          fields = obj.new.struct_fields.to_a.sort_by{|f| f.first}.map{|f| f.last }
          template = ERB.new(struct_template_string)
          File.open("#{output}/#{obj}.scala", "w") {|f| f.print(template.result(binding)) }
          
          # We assume that you'll have a single thrift exception type for your app.
          $exception = obj if obj.superclass == ::Thrift::Exception
        else
          # This is probably the service class.  Again, we're assuming a single one.
          # TODO: better detection and multiple services
          $service = Kernel.const_get(obj.to_s.split("::").first)
        end
      end
    end

    # Actually parsing the service is a little more complicated than doing the structs.
    obj = $service
    methods = obj.constants.map{|c| c.to_s[/(.*)_args$/, 1] }.compact.map(&:downcase).map {|name|
      out = MStruct.new
      out.name = name
      out.args = obj.const_get(name.capitalize + "_args").new.struct_fields.to_a.sort_by{|f| f.first}.map{|f| f.last }
      out.retval = obj.const_get(name.capitalize + "_result").new.struct_fields[0]
      out
    }
    template = ERB.new(service_template_string, nil, nil, "@output")
    File.open("#{output}/#{obj}.scala", "w") {|f| f.print(template.result(binding)) }
  end
  extend self
end
